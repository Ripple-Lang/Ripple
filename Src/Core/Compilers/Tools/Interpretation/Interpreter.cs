using System;
using System.CodeDom.Compiler;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CSharp;
using Ripple.Compilers.CodeGenerations;
using Ripple.Compilers.ErrorsAndWarnings;
using Ripple.Compilers.Options;

namespace Ripple.Compilers.Tools.Interpretation
{
    /// <summary>
    /// C#コードを生成してそれを実行するインタープリターです。
    /// </summary>
    public class Interpreter
    {
        private readonly CodeGenerationResult codeGenerationResult;
        private readonly CodeDomProvider provider;
        private readonly CompileOption option;

        /// <summary>
        /// 入力された関数を変換したC#コードを取得します。このコードは、フォーマットされていません。
        /// </summary>
        public string CSharpCode
        {
            get { return codeGenerationResult.GeneratedCode; }
        }

        public IErrorsAndWarningsContainer ErrorsAndWarnings
        {
            get { return codeGenerationResult.ErrorsAndWarnings; }
        }

        public bool HasErrors
        {
            get { return codeGenerationResult.ErrorsAndWarnings.HasErrors; }
        }

        public Interpreter(CodeDomProvider provider, CompileOption option)
            : this("", provider, option)
        { }

        public Interpreter(string src, CodeDomProvider provider, CompileOption option)
        {
            var task = new CSharpCodeGenerator().GenerateCodeAsync(src, option, null);
            task.Wait();
            this.codeGenerationResult = task.Result;
            this.provider = provider;
            this.option = option;
        }

        public Task<InterpretationResult> InterpretAsync(string src)
        {
            return Task<InterpretationResult>.Run(async () =>
            {
                if (HasErrors)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.AppendLine("コンパイル中にエラーが発生したため、解釈できません。");
                    sb.AppendLine("発生したエラーは次の通りです。");
                    foreach (var item in codeGenerationResult.ErrorsAndWarnings.Errors)
                    {
                        sb.AppendLine(item.Detail);
                    }

                    return new InterpretationResult(null, sb.ToString());
                }

                string newMethodName = "___AutoGeneratedMethod";
                string newClassName = codeGenerationResult.ClassName + "ForInterpret";

                ErrorsAndWarningsContainer interpretationErrors = new ErrorsAndWarningsContainer();

                var newResult = await new CSharpCodeGenerator().GenerateCodeAsync(
                    string.Format("func {0}() = {1}{2}", newMethodName, src, src.EndsWith(";") ? "" : ";"),
                    new CompileOption() { NameSpaceName = codeGenerationResult.NamespaceName, ClassName = newClassName },
                    new[] { codeGenerationResult.ProgramUnit });

                if (newResult.ErrorsAndWarnings.HasErrors)
                {
                    StringBuilder errorSb = new StringBuilder();
                    errorSb.AppendLine("インタープリター :");
                    foreach (var error in newResult.ErrorsAndWarnings)
                    {
                        errorSb.AppendLine("  " + error.Detail);
                    }
                    return new InterpretationResult(null, errorSb.ToString());
                }

                // C#コード生成
                string newCode = codeGenerationResult.GeneratedCode + Environment.NewLine + newResult.GeneratedCode;

                // C#コードのコンパイル
                var compiler = new Compiler(provider);
                var result = await compiler.CompileFromCSharpCodeAsync(newCode, option);

                if (result.CSharpCompilerResults.Errors.HasErrors)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.AppendLine("C#コンパイラがエラーを報告しました。");
                    foreach (var item in result.CSharpCompilerResults.Errors)
                    {
                        sb.AppendLine(item.ToString());
                    }

                    return new InterpretationResult(null, sb.ToString());
                }
                else
                {
                    return new InterpretationResult(result.CSharpCompilerResults
                        .CompiledAssembly
                        .GetType(newResult.NamespaceName + "." + newClassName)
                        .GetMethod(newMethodName)
                        .Invoke(null, null));
                }
            });
        }
    }

    public class InterpretationResult
    {
        public object Result { get; private set; }
        public string Message { get; private set; }

        public InterpretationResult(object result, string message = "")
        {
            this.Result = result;
            this.Message = message;
        }

        public override string ToString()
        {
            if (Result != null)
            {
                return Result.ToString();
            }
            else
            {
                return Message;
            }
        }
    }
}
